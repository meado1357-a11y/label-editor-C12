<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ê¸€ë˜ìŠ¤ë§ˆì¼“ V22.0 (Resizable + System Fonts)</title>
    <script src="https://unpkg.com/fabric@5.3.0/dist/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body { margin: 0; padding: 0; background: #f0f0f0; font-family: 'Pretendard', sans-serif; display: flex; flex-direction: column; align-items: center; }
        .controls { position: fixed; top: 10px; left: 10px; background: white; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.4); z-index: 10000; width: 310px; min-width: 250px; max-width: 600px; max-height: 95vh; overflow: auto; resize: both; container-type: inline-size; }
        .controls-header { background: linear-gradient(135deg, #ff85b1 0%, #ff7e5f 100%); color: white; padding: 15px; cursor: move; font-weight: bold; text-align: center; border-radius: 12px 12px 0 0; font-size: 5cqw; }
        .controls-content { padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .switch-box { background: #f8f9fa; padding: 10px; border-radius: 8px; display: flex; align-items: center; justify-content: space-between; font-size: 4cqw; font-weight: bold; border: 1px solid #eee; }
        .btn-main { background: #ffffff; border: 2px solid #ff85b1; color: #ff85b1; width: 100%; font-size: 4cqw; padding: 3cqw; cursor: pointer; font-weight: bold; border-radius: 8px; transition: 0.2s; }
        .btn-main:hover { background: #ff85b1; color: white; }
        .btn-group-row { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
        .btn-sub { padding: 2.5cqw 0; border: none; border-radius: 6px; font-weight: bold; font-size: 3.5cqw; cursor: pointer; }
        .btn-undo { background: #e7f5ff; color: #1971c2; }
        .btn-del { background: #fff5f5; color: #fa5252; }
        .btn-clear { background: #f1f3f5; color: #495057; }
        .btn-save-max { background: linear-gradient(to right, #ff7e5f, #feb47b); color: white; padding: 4cqw; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 4.5cqw; margin-top: 5px; box-shadow: 0 4px 10px rgba(255, 126, 95, 0.3); }
        .btn-print-direct { background: white; border: 2px solid #ff7e5f; color: #ff7e5f; padding: 3cqw; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 4cqw; transition: 0.2s; margin-top: 5px; }
        .text-panel { background: #fff0f6; padding: 10px; border-radius: 8px; border: 1px solid #ffdeeb; display: flex; flex-direction: column; gap: 8px; }
        .select-input { padding: 2cqw; border: 1px solid #ddd; border-radius: 6px; font-size: 3.5cqw; }
        
        /* ì‹œìŠ¤í…œ ê¸€ê¼´ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        .btn-font-sync { background: #ffe3e3; border: 1px dashed #ff85b1; color: #ff85b1; font-size: 2.8cqw; padding: 5px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; flex-shrink: 0; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 20px; }
        .slider:before { position: absolute; content: ""; height: 14px; width: 14px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #ff85b1; }
        input:checked + .slider:before { transform: translateX(20px); }
        .info-box { background:#fff9db; padding:10px; border-radius:8px; font-size:3.2cqw; color: #856404; border: 1px solid #ffec99; line-height: 1.4; }
        .page { width: 210mm; height: 297mm; background: white; margin: 20px; display: grid; grid-template-columns: repeat(3, 63mm); grid-template-rows: repeat(4, 63mm); padding: 15mm 6.5mm 16.02mm 6.5mm; column-gap: 4mm; row-gap: 4.66mm; box-sizing: border-box; box-shadow: 0 0 30px rgba(0,0,0,0.3); position: relative; }
        .circle-slot { width: 63mm; height: 63mm; position: relative; display: flex; justify-content: center; align-items: center; border-radius: 50%; border: 1px dashed #ff85b1; background: #fff; overflow: hidden; }
        .individual-btn { position: absolute; top: 5px; z-index: 100; background: rgba(0,0,0,0.6); color: white; border: none; padding: 2px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; }
        .sync-wrapper { position: absolute; bottom: 5px; z-index: 100; font-size: 10px; background: white; padding: 2px 8px; border-radius: 20px; border: 1px solid #eee; cursor: pointer; display: flex; align-items: center; gap: 4px; }
        @media print { .no-print { display: none !important; } body { background: white; } .page { margin: 0; box-shadow: none; border: none; } }
    </style>
</head>
<body>

<div class="controls no-print" id="dragBox">
    <div class="controls-header" id="dragHandle">âœ¨ê¸€ë˜ìŠ¤ë§ˆì¼“ ë¼ë²¨ì—ë””í„° V22.0</div>
    <div class="controls-content">
        <div class="switch-box">
            <span>ğŸ›¡ï¸ì˜¤ì°¨ ë°©ì§€ ê¸°ëŠ¥ (2mm í™•ì¥)</span>
            <label class="switch"><input type="checkbox" id="bleedToggle" checked><span class="slider"></span></label>
        </div>
        <div class="switch-box">
            <span>ğŸ”— ëª¨ë“  ì¹¸ ë™ê¸°í™”</span>
            <label class="switch"><input type="checkbox" id="allSyncToggle" checked onchange="toggleAllSync(this.checked)"><span class="slider"></span></label>
        </div>
        <button class="btn-main" onclick="document.getElementById('fileAll').click()">ğŸ–¼ï¸ ì‚¬ì§„ ì¼ê´„ ë“±ë¡</button>
        <input type="file" id="fileAll" accept="image/*" style="display:none;" onchange="loadAllImages(event)">
        
        <div class="btn-group-row">
            <button class="btn-sub btn-undo" onclick="undo()">â†©ï¸ ì·¨ì†Œ</button>
            <button class="btn-sub btn-del" onclick="deleteSelected()">ğŸ—‘ï¸ ì‚­ì œ</button>
            <button class="btn-sub btn-clear" onclick="clearAll()">ğŸ”¥ ì´ˆê¸°í™”</button>
        </div>

        <div class="text-panel">
            <button class="btn-main" style="background:#ff85b1; color:white; border:none;" onclick="addText()">â• ê¸€ìƒì ì¶”ê°€</button>
            <div style="display:flex; gap:5px;">
                <select id="fontSelect" class="select-input" style="flex:2;" onchange="updateFont()">
                    <option value="Pretendard">Pretendard</option>
                    <option value="Gungsuh">ê¶ì„œì²´</option>
                </select>
                <input type="color" id="textColor" value="#000000" style="flex:1; height:35px; border:none; cursor:pointer;" onchange="updateTextColor()">
            </div>
            <button class="btn-font-sync" onclick="loadSystemFonts()">ğŸ”„ PC ê¸€ê¼´ ë™ê¸°í™”</button>
        </div>

        <button class="btn-save-max" onclick="exportLossless()">ğŸ’¾ ì´ˆê³ í™”ì§ˆ PDF ì €ì¥</button>
        <button class="btn-print-direct" onclick="window.print()">ğŸ–¨ï¸ ë°”ë¡œ ì¸ì‡„í•˜ê¸°</button>

        <div class="info-box">
            <b>ğŸ’¡ ì¸ì‡„ ì„¤ì • TIP !</b><br>
            ë°°ìœ¨ : 100 %<br> ì—¬ë°± : ì—†ìŒ <br> ë°°ê²½ê·¸ë˜í”½ : ì²´í¬ í™œì„±
        </div>
    </div>
</div>

<div class="page" id="labelPage">
    <script>
        const canvases = [];
        const SIZE = 350; 
        const CENTER = SIZE / 2;
        let historyStack = [];

        for (let i = 0; i < 12; i++) {
            document.write(`
                <div class="circle-slot" id="slot${i}">
                    <button class="individual-btn no-print" onclick="document.getElementById('file${i}').click()">êµì²´</button>
                    <div class="sync-wrapper no-print" onclick="manualSyncToggle(${i})">
                        <input type="checkbox" class="sync-check" id="sync${i}" checked> <label>ë™ê¸°í™”</label>
                    </div>
                    <canvas id="canvas${i}"></canvas>
                    <input type="file" id="file${i}" accept="image/*" style="display:none;" onchange="loadImage(event, ${i})">
                </div>
            `);
        }

        window.onload = function() {
            for (let i = 0; i < 12; i++) {
                const canvas = new fabric.Canvas('canvas' + i, { width: SIZE, height: SIZE, selection: true });
                canvas.clipPath = new fabric.Circle({ radius: CENTER, left: CENTER, top: CENTER, originX: 'center', originY: 'center', absolutePositioned: true });
                
                canvas.on('mouse:wheel', (opt) => {
                    const delta = opt.e.deltaY;
                    let zoom = canvas.getZoom() * Math.pow(0.999, delta);
                    zoom = Math.max(zoom, 1.0); 
                    zoom = Math.min(zoom, 15);
                    const point = new fabric.Point(CENTER, CENTER);
                    if (document.getElementById('sync' + i).checked) {
                        canvases.forEach((c, idx) => { 
                            if (document.getElementById('sync' + idx).checked) { 
                                c.zoomToPoint(point, zoom); 
                                c.renderAll(); 
                            } 
                        });
                    } else { 
                        canvas.zoomToPoint(point, zoom); 
                        canvas.renderAll(); 
                    }
                    opt.e.preventDefault();
                });
                
                canvas.on('object:modified', saveState);
                canvas.on('object:moving', (e) => syncObjects(i, e));
                canvas.on('object:scaling', (e) => syncObjects(i, e));
                canvas.on('object:rotating', (e) => syncObjects(i, e));
                canvases.push(canvas);
            }
            saveState();
            initDraggable(document.getElementById("dragBox"));
        };

        // ì‹œìŠ¤í…œ ê¸€ê¼´ ë¡œë“œ í•¨ìˆ˜
        async function loadSystemFonts() {
            if (!window.queryLocalFonts) {
                alert("ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ê¸€ê¼´ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. (ìµœì‹  í¬ë¡¬ ê¶Œì¥)");
                return;
            }
            try {
                const fonts = await window.queryLocalFonts();
                const fontSelect = document.getElementById('fontSelect');
                const uniqueFonts = [...new Set(fonts.map(f => f.family))].sort();
                
                uniqueFonts.forEach(font => {
                    const opt = document.createElement('option');
                    opt.value = font;
                    opt.textContent = font;
                    fontSelect.appendChild(opt);
                });
                alert(uniqueFonts.length + "ê°œì˜ ê¸€ê¼´ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!");
            } catch (e) {
                alert("ê¸€ê¼´ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.");
            }
        }

        function saveState() {
            const state = canvases.map(c => JSON.stringify(c.toJSON()));
            historyStack.push(state);
            if (historyStack.length > 20) historyStack.shift();
        }

        function undo() {
            if (historyStack.length <= 1) return;
            historyStack.pop();
            const lastState = historyStack[historyStack.length - 1];
            lastState.forEach((json, i) => {
                canvases[i].loadFromJSON(json, () => {
                    canvases[i].clipPath = new fabric.Circle({ radius: CENTER, left: CENTER, top: CENTER, originX: 'center', originY: 'center', absolutePositioned: true });
                    canvases[i].renderAll();
                });
            });
        }

        function deleteSelected() {
            canvases.forEach(c => {
                c.getActiveObjects().forEach(obj => c.remove(obj));
                c.discardActiveObject().renderAll();
            });
            saveState();
        }

        function clearAll() {
            if(confirm("ëª¨ë“  í¸ì§‘ ë‚´ìš©ì„ ì‚­ì œí• ê¹Œìš”?")) {
                canvases.forEach(c => c.clear());
                saveState();
            }
        }

        function toggleAllSync(isChecked) { document.querySelectorAll('.sync-check').forEach(chk => chk.checked = isChecked); }
        function manualSyncToggle(i) { const chk = document.getElementById('sync' + i); chk.checked = !chk.checked; }

        function syncObjects(masterIdx, e) {
            if (!document.getElementById('sync' + masterIdx).checked) return;
            const masterObj = e.target;
            const objIdx = canvases[masterIdx].getObjects().indexOf(masterObj);
            canvases.forEach((canvas, idx) => {
                if (idx === masterIdx || !document.getElementById('sync' + idx).checked) return;
                const targetObj = canvas.getObjects()[objIdx];
                if (targetObj) {
                    targetObj.set({ left: masterObj.left, top: masterObj.top, scaleX: masterObj.scaleX, scaleY: masterObj.scaleY, angle: masterObj.angle });
                    canvas.renderAll();
                }
            });
        }

        function loadImage(event, index) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (f) => {
                fabric.Image.fromURL(f.target.result, (img) => {
                    img.set({ originX: 'center', originY: 'center', left: CENTER, top: CENTER });
                    const scale = SIZE / Math.min(img.width, img.height);
                    img.scale(scale);
                    canvases[index].add(img).setActiveObject(img);
                    saveState();
                });
            };
            reader.readAsDataURL(file);
        }

        function loadAllImages(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (f) => {
                canvases.forEach(canvas => {
                    fabric.Image.fromURL(f.target.result, (img) => {
                        img.set({ originX: 'center', originY: 'center', left: CENTER, top: CENTER });
                        const scale = SIZE / Math.min(img.width, img.height);
                        img.scale(scale);
                        canvas.add(img);
                    });
                });
                setTimeout(saveState, 500);
            };
            reader.readAsDataURL(file);
        }

        function addText() {
            const text = new fabric.IText('í…ìŠ¤íŠ¸ì…ë ¥', { 
                left: CENTER, top: CENTER, originX: 'center', originY: 'center', 
                fontSize: 25, fontFamily: document.getElementById('fontSelect').value, fill: document.getElementById('textColor').value 
            });
            canvases.forEach(c => { c.add(text); c.renderAll(); });
            saveState();
        }

        function updateFont() {
            const font = document.getElementById('fontSelect').value;
            canvases.forEach(canvas => { canvas.getObjects('i-text').forEach(obj => obj.set('fontFamily', font)); canvas.renderAll(); });
            saveState();
        }

        function updateTextColor() {
            const color = document.getElementById('textColor').value;
            canvases.forEach(canvas => { canvas.getObjects('i-text').forEach(obj => obj.set('fill', color)); canvas.renderAll(); });
            saveState();
        }

        async function exportLossless() {
            const btn = event.target;
            const originalText = btn.innerText;
            btn.innerText = "ë Œë”ë§ ì¤‘..."; btn.disabled = true;
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const offCanvas = document.createElement('canvas');
            const offCtx = offCanvas.getContext('2d');
            offCanvas.width = 2480; offCanvas.height = 3508;
            offCtx.fillStyle = "white"; offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);
            const scaleFactor = offCanvas.width / 210;
            const isBleed = document.getElementById('bleedToggle').checked;
            const bleedMargin = 1.0 * scaleFactor; 

            for (let i = 0; i < 12; i++) {
                const col = i % 3; const row = Math.floor(i / 3);
                const startX = 6.5 * scaleFactor; const startY = 15 * scaleFactor;
                const slotW = 63 * scaleFactor; const gapX = 4 * scaleFactor; const gapY = 4.66 * scaleFactor;
                const posX = startX + (col * (slotW + gapX));
                const posY = startY + (row * (slotW + gapY));
                const finalRadius = isBleed ? (slotW / 2) + bleedMargin : (slotW / 2);
                const drawSize = isBleed ? slotW + (bleedMargin * 2) : slotW;
                const drawPosX = isBleed ? posX - bleedMargin : posX;
                const drawPosY = isBleed ? posY - bleedMargin : posY;

                const dataURL = canvases[i].toDataURL({ format: 'png', multiplier: drawSize / SIZE });
                const img = await new Promise(resolve => { const img = new Image(); img.onload = () => resolve(img); img.src = dataURL; });
                offCtx.save();
                offCtx.beginPath();
                offCtx.arc(posX + (slotW/2), posY + (slotW/2), finalRadius, 0, Math.PI * 2);
                offCtx.clip();
                offCtx.drawImage(img, drawPosX, drawPosY, drawSize, drawSize);
                offCtx.restore();
            }
            pdf.addImage(offCanvas.toDataURL('image/jpeg', 1.0), 'JPEG', 0, 0, 210, 297, undefined, 'SLOW');
            pdf.save('glassmarket_v22.pdf');
            btn.innerText = originalText; btn.disabled = false;
        }

        function initDraggable(el) {
            let p1 = 0, p2 = 0, p3 = 0, p4 = 0; const h = document.getElementById("dragHandle");
            h.onmousedown = (e) => { 
                if (e.target !== h) return;
                e.preventDefault(); 
                p3 = e.clientX; p4 = e.clientY; 
                document.onmouseup = () => { document.onmouseup = null; document.onmousemove = null; }; 
                document.onmousemove = (e) => { 
                    p1 = p3 - e.clientX; p2 = p4 - e.clientY; p3 = e.clientX; p4 = e.clientY; 
                    el.style.top = (el.offsetTop - p2) + "px"; el.style.left = (el.offsetLeft - p1) + "px"; 
                }; 
            };
        }
    </script>
</div>
</body>
</html>
